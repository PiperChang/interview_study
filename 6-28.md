# React 시작
## React 는? 라이브러리인가 프레임워크인가?
프레임워크는 앱 개발 시 "필요한 기능들이 이미 구성이 된 뼈대"를 제공해주는 것이다.
라이브러리는 앱 개발 시 "특정 기능에 대한 도구를 모은 집합"입니다.

둘의 차이점은 '제어 흐름의 권한을 누가 가지고 있느냐'입니다. 즉, 내가 짜는 코드가 외부 코드를 호출하면 라이브러리, 외부 코드가 내가 짜는 코드를 호출하면 프레임워크라는 말이죠.

### 그래서 리액트는 둘 중 뭐라는 건데?

리액트는 UI 개발을 위한 라이브러리입니다. 그렇기에, "필요한 부분에서만 조금씩 리액트를 사용할 수도 있습니다". 즉, 우리는 UI를 build하기 위해, React라는 도구를 이용하는 것이라는 거죠.

### 근데 React의 규칙에 따라서, 우리가 코딩을 하잖아? 그럼 프레임워크 아니야?

우리는 React의 규칙에 따라서 컴포넌트를 만들고, React가 그것을 불러와서 UI로 불러옵니다. 이런 점 때문에 프레임워크같은 측면을 보일 수 있죠. 그럼에도 결과적으로는 큰 시야에서 보았을 때, 
React라는 라이브러리를 import 해서 그 기능을 사용하는 것이라고 보는 게 더 타당하다는 것입니다. 

그 외에도, 리액트가 프레임워크라고 하기에 부족하다고 여겨지는 또 다른 이유는 React가 라우팅과 같은 기능들을 위해서는 3rd party 라이브러리들을 이용해야만 하기에, 프레임워크가 되기 위해 필요한 기능들을 충분히 가지고 있지 못하다고도 합니다.


결국, React는 다른 Library들의 이용을 통해 프레임워크 급의 생태계를 만들수 있지만, 그 자체만으로는 라이브러리이다.... 라고 할 수 있겠습니다.
 
리액트는 컴포넌트 단위로 UI를 구성함으로서 재사용을 통해 코드량을 줄일 수 있고, 렌더링 역시 비효율적인 DOM 조작을 

## 왜 React를 사용하나요?
1. 컴포넌트 기반의 화면 구성
컴포넌트 기반으로 화면을 관리함으로써, 코드 재사용성을 높여줍니다.
 
2. Virtual DOM으로 인한 충분히 빠른 속도


3. SPA

- component 사용해서 유지보수의 용이함(필요 부분의 component만 렌더링 됨. 최적화된 렌더링 가능)
- 생태계가 넓고, 다양한 라이브러리 사용 가능
- virtual DOM 활용하여 빠른 렌더링 가능

## Virtual DOM이란?
화면에 렌더링이 일어날 때, DOM, CSSOM, Render 트리 그리고, 페인팅까지 하는 과정을 거치게 됩니다.

이는 DOM에 변화가 일어날 때도 마찬가지입니다.

Virtual DOM은 변경을 위한 요청이 오면, 
1. 현재 실제 DOM의 데이터를 가져옵니다.
2. 그 다음에 변화가 되는 것을 Virtual Dom에 반영합니다. ( 이런 요청을 전부다 반영 시킵니다 ) * 무한
3. Virtual DOM의 변화가 끝나면 실제 DOM을 변화시킵니다.

### 궁금증 : 비교해서 달라진 부분만 변화시킨다고 하는데, 이게 달라진 부분을 Virtual DOM에서 계속 변화시킨다는 건지? 아니면 마지막 Virtual DOM에서 Render Tree가 될 때, 기존 Render tree에서 달라진 부분만 변화시킨다는 것인지?



## 함수형 컴포넌트와 클래스 컴포넌트의 차이
#### 클래스 컴포넌트
- 객체 지향 구조, state 초기화 위해서는 constructor 함수 필요.
- 생성자 함수 통해 state 초기화 해야해서 코드가 길어지고 사이즈 커짐.
- state 기능 및 라이프 사이클 기능 활용 가능, 임의의 메서드 정의 가능함.
- render 함수 있어야 하고, 그 안에서 JSX 반환

#### 함수형 컴포넌트
- Hooks 사용해서 생성자 함수 통해 state 초기화 않고 사용 가능
- 선언이 편하고 메모리 적게 사용
- 커스텀 Hook 생성해서 동작가능
- 프로젝트 빌드 배포 시에도 결과 파일 크기가 작음
- 원래, state, 라이프사이클 API 사용 불가능했는데, 이후 업데이트에서 나온 Hooks를 통해 해결됨 


## Props와 State의 차이
props는 부모 컴포넌트가 주는 거고 그래서 변경하려면, 부모 컴포넌트가 변경을 해야 한다. state는 컴포넌트 내부에서 존재하는 변경가능한 값으로, 해당 컴포넌트가 변경을 할 수 있습니다.
props는 부모에서 자식으로 내려오는 겁니다. 역으로 자식에서 부모로 데이터를 전송하려면, 부모가 함수를 props로 넣고, 자식이 그 함수를 통해서 값을 건네주는 방식으로 할 수 있습니다.


# 리덕스 
리덕스는 페이스북에서 리액트가 함께 소개한 FLUX 아키텍쳐로 구현한 라이브러리입니다.

## Flux ?
라이브러리나 프레임워크가 아닌 그냥 '추상적인 개념'이다.
MVC 패턴이 쌍방향적 데이터 흐름을 강조했다고 하면, Flux는 단방향 데이터 흐름을 강조한다.
MVC 패턴은 사용할 뷰랑 모델이 적다면, 매우 효율적인 구조이다.
하지만, 모델이랑 뷰가 복잡하게 얽혀 있다면 어떤 모델이 바뀌어서 뷰가 영향을 받았는지 확인할 수가 없는 경우가 생긴다.

이런 문제를 위한 개념이 Flux다.
`행위Action`은 `디스패쳐Dispatcher`에 의해 통제되고, `디스패처`가 `스토어Store`를 업데이트하고, 변경된 `스토어`에 대한 `뷰`를 리렌더링한다.
`뷰`에서는 `스토어`에 직접 접근하지 않으며, `디스패처`로 다시 액션을 보내고 `스토어`를 업데이트하고, 다시 `뷰`를 리렌더링하는 구조를 가진다.
그 덕에, Flux는 단방향적 데이터 흐름을 통해 어떤 액션이 어떤 결과를 낳는지 명확히 파악할 수 있게 한다.

## Redux ?
리덕스는 스토어라는 변수를 통해 전역 상태관리를 하게 된다.
전역으로 상태를 관리하기 때문에, 부모 자식에 상관없이 사용가능합니다.

### Redux의 기본 원칙
1. 응용 프로그램의 전역상태는 단일 저장소 내의 트리에 저장됩니다.
2. 상태는 읽기 전용입니다.
3. 순수 함수에 의해 변경되어야 합니다.
- 순수 함수 : 부수 효과를 일으키지 않는 함수
### React의 state 불변성을 유지하라는 말이 뭔 말ㅇ니가?
객체는 실제 데이터가 아닌 참조 값을 가집니다. 그래서, 동일한 참조 값을 가지는 객체 중 하나라도 변경되면, 모든 객체의 내부 값이 변경되게 됩니다.
그래서, 객체 내의 값을 변경하면 안된다는 겁니다. 그럼 상태의 내용의 변경은 어떻게 되는 걸까요? 새로운 객체 ( 다른 객체 )에 값을 다시 저장해서 사용합니다.
`...스프레드 연산자`가 이 때 유용합니다. 같은 값을 가지는 새로운 객체를 만드는 데에 유용한 거죠.

### Reducer에서 불변성을 지키는 이유는 뭔가요? 전개 연산자의 단점을 해결할 수 있는 방법은 무엇인가요?
- 컴포넌트는 다음과 같은 경우에 업데이트합니다.
1. props가 바뀔 때,
2. state가 바뀔 때.
3. 부모 컴포넌트가 리렌더링 될 때
4. this.forceUpdate로 강제로 렌더링을 트리거할 때
리듀서의 initialState에는 서버에서 넘겨받는 정보를 저장하고 전역으로 해당 객체를 사용할 수 있는 저장소 역할을 합니다.
불변성을 지킴으로써 각각의 고유한 참조값을 가지는 객체를 복사해서 사용함으로 어떤 함수가 호출됐을 때 같은 객체를 참조시 생길 수 있는 불필요한 리렌더링과 부수효과를 줄일 수 있습니다.
근데, 스프레드 연산자를 사용해서 객체를 복사하면, 로직 구성이 어려울 수 있습니다. `immer` 라이브러리는 이를 해결하기 위해 등장했습니다.
`produce`, `draft` 키워들르 통해 기존 spread 연산자 사용없이 불변성을 유지하고 사이드 이펙트를 막아줍니다.




